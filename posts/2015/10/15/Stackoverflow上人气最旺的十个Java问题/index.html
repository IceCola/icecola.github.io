<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Stackoverflow上人气最旺的十个Java问题 | Ola</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、 为什么两个（1927年）时间相减得到一个奇怪的结果？（3623个赞）
如果执行下面的程序，程序解析两个间隔1秒的日期字符串并比较：

public static void main(String[] args) throws ParseException {    SimpleDateFormat sf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”">
<meta property="og:type" content="article">
<meta property="og:title" content="Stackoverflow上人气最旺的十个Java问题">
<meta property="og:url" content="http://yoursite.com/posts/2015/10/15/Stackoverflow上人气最旺的十个Java问题/index.html">
<meta property="og:site_name" content="Ola">
<meta property="og:description" content="1、 为什么两个（1927年）时间相减得到一个奇怪的结果？（3623个赞）
如果执行下面的程序，程序解析两个间隔1秒的日期字符串并比较：

public static void main(String[] args) throws ParseException {    SimpleDateFormat sf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”">
<meta property="og:updated_time" content="2015-10-15T15:36:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stackoverflow上人气最旺的十个Java问题">
<meta name="twitter:description" content="1、 为什么两个（1927年）时间相减得到一个奇怪的结果？（3623个赞）
如果执行下面的程序，程序解析两个间隔1秒的日期字符串并比较：

public static void main(String[] args) throws ParseException {    SimpleDateFormat sf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Ola</a></h1>
		</hgroup>

		
		<p class="header-subtitle">火力全開</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">首页</a></li>
				        
							<li><a href="/archives">归档</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/OS-X/" style="font-size: 10px;">OS X</a> <a href="/tags/Octopress/" style="font-size: 10px;">Octopress</a> <a href="/tags/blog/" style="font-size: 20px;">blog</a> <a href="/tags/环境配置/" style="font-size: 10px;">环境配置</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我们‘记得’过去,但和这个‘过去’相逢时却对面不识。思想总在回溯,但是时光一直前行,一旦分离,即是永诀。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Ola</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Ola</h1>
			</hgroup>
			
			<p class="header-subtitle">火力全開</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">首页</a></li>
		        
					<li><a href="/archives">归档</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Stackoverflow上人气最旺的十个Java问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/2015/10/15/Stackoverflow上人气最旺的十个Java问题/" class="article-date">
  	<time datetime="2015-10-15T12:18:47.000Z" itemprop="datePublished">2015-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Stackoverflow上人气最旺的十个Java问题
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/编程/">编程</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、_为什么两个（1927年）时间相减得到一个奇怪的结果？">1、 <a href="http://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result" target="_blank" rel="external">为什么两个（1927年）时间相减得到一个奇怪的结果？</a></h3><p>（3623个赞）</p>
<p>如果执行下面的程序，程序解析两个间隔1秒的日期字符串并比较：</p>
<blockquote>
<p>public static void main(String[] args) throws ParseException {<br>    SimpleDateFormat sf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);<br>    String str3 = “1927-12-31 23:54:07”;<br>    String str4 = “1927-12-31 23:54:08”;<br>    Date sDt3 = sf.parse(str3);<br>    Date sDt4 = sf.parse(str4);<br>    long ld3 = sDt3.getTime() /1000;<br>    long ld4 = sDt4.getTime() /1000;<br>    System.out.println(ld4-ld3);<br>}</p>
</blockquote>
<p>输出是：</p>
<blockquote>
<p>353</p>
</blockquote>
<p>为什么 ld4-ld3 不是1（因为我希望这两个时间差是一秒），而是353？</p>
<p>如果将日期字符串各加一秒：</p>
<blockquote>
<p>String str3 = “1927-12-31 23:54:08”;<br>String str4 = “1927-12-31 23:54:09”;</p>
</blockquote>
<p>ld4-ld3 的结果是1.</p>
<blockquote>
<p>sun.util.calendar.ZoneInfo[id=”Asia/Shanghai”,<br>offset=28800000,dstSavings=0,<br>useDaylight=false,<br>transitions=19,<br>lastRule=null]<br>Locale(Locale.getDefault()): zh_CN</p>
</blockquote>
<p><strong>解决方案</strong></p>
<p>这是上海时区，在12月31日有一个变化。</p>
<p>查阅<a href="http://www.timeanddate.com/worldclock/clockchange.html?n=237&amp;year=1927" target="_blank" rel="external">这个网址</a>来了解上海在1927年时区变化的细节。基本上在1927年年底的午夜，始终会回拨5分52秒。所以“1927-12-31 23:54:08”实际上发生了两次，看起来Java解析了后一次的时间作为当地的日期和时间导致了差异。</p>
<h3 id="2、Java是“引用传递”还是“值传递”？">2、<a href="http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="external">Java是“引用传递”还是“值传递”？</a></h3><p>（2480个赞）</p>
<p>我一直认为Java是引用传递；然而，我看了一堆博客（例如<a href="http://javadude.com/articles/passbyvalue.htm" target="_blank" rel="external">这篇</a>）声称不是这样的。我认为我没有理解它们之间的区别。</p>
<p>给个解释？</p>
<p><strong>解决方案</strong></p>
<p>Java一直是<strong>值传递</strong>。不幸的是，他们决定把指针叫做引用，因此新人总是被搞晕。因为这些<strong>引用</strong>也是通过值传递的。</p>
<h3 id="3、一个关于Java_+=_操作符的问题">3、一个关于<a href="http://stackoverflow.com/questions/8710619/java-operator" target="_blank" rel="external">Java +=</a> 操作符的问题</h3><p>（2223赞）  </p>
<p>直到今天我认为这个例子：</p>
<blockquote>
<p>i += j;</p>
</blockquote>
<p>只是一个简写的：</p>
<blockquote>
<p>i = i + j;</p>
</blockquote>
<p>但如果这样做：</p>
<blockquote>
<p>int i = 5;<br>long j = 8;</p>
</blockquote>
<p>然而 i = i + j; 没法编译，而 i += j; 就可以编译。</p>
<p>这意味着i += j; 实际上是i = (type of i) (i + j)的简写么？</p>
<p><strong>解决方案</strong></p>
<p>总有人问这类问题，JLS里有答案。参见 <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2" target="_blank" rel="external">§15.26.2复合赋值运算符</a>。摘录：</p>
<p>E1 op= E2 型的复合赋值表达式等价于 E1 = (T)((E1) op (E2))，这里 T 是 E1 的类型，不同的是 E1 只计算一次。</p>
<p>一个例子，引自 <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2" target="_blank" rel="external">§15.26.2</a></p>
<p>[…] 下面的代码是正确的：</p>
<blockquote>
<p>short x = 3;<br>x += 4.6;</p>
</blockquote>
<p>x的结果等于7，因为它等价于：</p>
<blockquote>
<p>short x = 3;<br>x = (short)(x + 4.6);</p>
</blockquote>
<p>换句话说，你的假设是正确的。</p>
<a id="more"></a>
<h3 id="4、HashMap_和_Hashtable_之间的不同?">4、<a href="http://stackoverflow.com/questions/40471/differences-between-hashmap-and-hashtable" target="_blank" rel="external">HashMap 和 Hashtable 之间的不同?</a></h3><p>（1769个赞）<br>Java中 HashMap 和 Hashtable的不同是什么？</p>
<p>非多线程应用中使用哪个更有效率？</p>
<p><strong>解决方案</strong></p>
<p>Java 中 HashMap 和 HashTable 有几个不同点：</p>
<ol>
<li><a href="http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html" target="_blank" rel="external">Hashtable</a> 是同步的，然而 <a href="http://java.sun.com/javase/7/docs/api/java/util/HashMap.html" target="_blank" rel="external">HashMap</a>不是。 这使得HashMap更适合非多线程应用，因为非同步对象通常执行效率优于同步对象。</li>
<li>Hashtable 不允许 null 值和键。HashMap允许有一个 null 键和一个 NULL 值。</li>
<li>HashMap的一个子类是<a href="http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="external">LinkedHashMap</a>。所以，如果想预知迭代顺序（默认的插入顺序），只需将HashMap转换成一个LinkedHashMap。用Hashtable就不会这么简单。</li>
</ol>
<p>因为同步对你来说不是个问题，我推荐使用HashMap。如果同步成为问题，你可能还要看看<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="external">ConcurrentHashMap</a>。</p>
<h3 id="5、（如何）读取或者把一个_InputStream_转成一个_String">5、（如何）<a href="http://stackoverflow.com/questions/309424/read-convert-an-inputstream-to-a-string" target="_blank" rel="external">读取或者把一个 InputStream 转成一个 String</a></h3><p>（1724个赞）</p>
<p>如果你有一个 java.io.InputStream 对象，如处理这个对象并生成一个字符串？</p>
<p>假定我有一个 InputStream 对象，它包含文本数据，我希望将它转化成一个字符串（例如，这样我可以将流的内容写到一个log文件中）。</p>
<p>InputStream 转化成 String 最简单方法是什么？</p>
<p><strong>解决方案</strong></p>
<p>使用 Apache commons <a href="http://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/IOUtils.html" target="_blank" rel="external">IOUtils</a>库来拷贝InputStream到StringWriter是一种不错的方式，类似这样：</p>
<blockquote>
<p>StringWriter writer = new StringWriter();<br>IOUtils.copy(inputStream, writer, encoding);<br>String theString = writer.toString();</p>
</blockquote>
<p>甚至</p>
<blockquote>
<p>// NB: does not close inputStream, you can use IOUtils.closeQuietly for that<br>// 注意：不关闭inputStream，你可以使用   IOUtils.closeQuietly<br>String theString = IOUtils.toString(inputStream, encoding);</p>
</blockquote>
<p>或者，如果不想混合Stream和Writer，可以使用 ByteArrayOutputStream。</p>
<h3 id="6、为什么Java中的密码优先使用_char[]_而不是String？">6、<a href="http://stackoverflow.com/questions/8881291/why-is-char-preferred-over-string-for-passwords-in-java" target="_blank" rel="external">为什么Java中的密码优先使用 char[] 而不是String？</a></h3><p>（1574个赞）</p>
<p>在Swing中，密码字段有一个getPassword()（返回 char数组）方法而不是通常的getText()（返回String）方法。同样的，我遇到过一个建议，不要使用 String 来处理密码。</p>
<p>为什么String涉及到密码时，它就成了一个安全威胁？感觉使用char数组不太方便。</p>
<p><strong>解决方案</strong></p>
<p>String是不可变的。这意味着一旦创建了字符串，如果另一个进程可以进行内存转储，在GC发生前，（除了反射）没有方法可以清除字符串数据。</p>
<p>使用数组操作完之后，可以显式地清除数据：可以给数组赋任何值，密码也不会存在系统中，甚至垃圾回收之前也是如此。</p>
<p>所以，是的，这是一个安全问题 – 但是即使使用了char数组，仅仅缩小了了攻击者有机会获得密码的窗口，它值针对制定的攻击类型。</p>
<h3 id="7、遍历HashMap的最佳方法">7、<a href="http://stackoverflow.com/questions/1066589/iterate-through-a-hashmap" target="_blank" rel="external">遍历HashMap</a>的最佳方法</h3><p>（1504个赞）</p>
<p>遍历HashMap中元素的最佳方法是什么？</p>
<p><strong>解决方案</strong></p>
<p>这样遍历<a href="http://www.java2s.com/Code/JavaAPI/java.util/HashtableentrySet.htm" target="_blank" rel="external">entrySet</a>：</p>
<blockquote>
<p>public static void printMap(Map mp) {<br>    Iterator it = mp.entrySet().iterator();<br>    while (it.hasNext()) {<br>        Map.Entry pair = (Map.Entry)it.next();<br>        System.out.println(pair.getKey() + “ = “ + pair.getValue());<br>        it.remove(); // avoids a ConcurrentModificationException<br>    }<br>}  </p>
</blockquote>
<p>更多请查阅<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html" target="_blank" rel="external">Map</a>。</p>
<h3 id="8、（如何）从数组创建ArrayList">8、（如何）<a href="http://stackoverflow.com/questions/157944/create-arraylist-from-array" target="_blank" rel="external">从数组创建ArrayList</a></h3><p>（1468个赞）</p>
<p>我有一个数组，初始化如下：</p>
<blockquote>
<p>Element[] array = {new Element(1), new Element(2), new Element(3)};</p>
<p>我希望将这个数组转化成一个ArrayList类的对象。</p>
</blockquote>
<p><strong>解决方案</strong></p>
<blockquote>
<p>new ArrayList<element>(Arrays.asList(array))</element></p>
</blockquote>
<h3 id="9、产生一个Java的内存泄露">9、<a href="http://stackoverflow.com/questions/6470651/creating-a-memory-leak-with-java" target="_blank" rel="external">产生一个Java的内存泄露</a></h3><p>（1478个赞）</p>
<p>我有过一个面试，被问到如何产生一个Java内存泄露。不用说，我感到相当傻，甚至如何产生一个的线索都没有。</p>
<p>那么怎么才能产生一个内存泄露呢？</p>
<p><strong>解决方案</strong></p>
<p>在纯Java中，有一个很好的方式可以产生真正的内存泄露（通过执行代码使对象不可访问但仍存在于内存中）：</p>
<ol>
<li>应用产生一个长时间运行的线程（或者使用一个线程池加速泄露）。</li>
<li>线程通过一个（可选的自定义）类加载器加载一个类。</li>
<li>该类分配大内存（例如，new byte[1000000]），赋值给一个强引用存储在静态字段中，再将它自身的引用存储到ThreadLocal中。分配额外的内存是可选的（泄露类实例就够了），但是这样将加速泄露工作。</li>
<li>线程清除所有自定义类的或者类加载器载入的引用。</li>
<li>重复上面步骤。</li>
</ol>
<p>这样是有效的，因为ThreadLocal持有对象的引用，对象持有类的引用，接着类持有类加载器的引用。反过来，类加载器持有所有已加载类的引用。这会使泄露变得更加严重，因为很多JVM实现的类和类加载都直接从持久带（permgen）分配内存，因而不会被GC回收。</p>
<h3 id="10、使用Java在一个区间内产生随机整数数">10、<a href="http://stackoverflow.com/questions/363681/generating-random-integers-in-a-range-with-java" target="_blank" rel="external">使用Java在一个区间内产生随机整数数</a></h3><p>（1422个赞）</p>
<p>我试着使用Java生成一个随机整数，但是随机被指定在一个范围里。例如，整数范围是5~10，就是说5是最小的随机值，10是最大的。5到10之间的书也可以是生成的随机数。<br>解决方案<br>标准的解决方式（Java1.7 之前）如下：</p>
<blockquote>
<p>import java.util.Random;<br>public static int randInt(int min, int max) {<br>    Random rand;<br>    int randomNum = rand.nextInt((max - min) + 1) + min;<br>    return randomNum;<br>}  </p>
</blockquote>
<p>请查看相关的<a href="http://stackoverflow.com/questions/363681/generating-random-integers-in-a-range-with-java" target="_blank" rel="external">JavaDoc</a>。在实践中，<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Random.html" target="_blank" rel="external">java.util.Random</a> 类总是优于 <a href="java.lang.Math.random(">java.lang.Math.random()</a>)。</p>
<p>特别是当标准库里有一个直接的API来完成这个工作，就没有必要重复制造轮子了。</p>
<hr>
<p>原文链接： <a href="http://www.nolsit.com/most-popular-java-questions-on-stackoverflow-w-12025/" target="_blank" rel="external">nolsit</a>  翻译： <a href="http://www.importnew.com/" target="_blank" rel="external">ImportNew.com</a> - <a href="http://www.importnew.com/author/wei-li" target="_blank" rel="external">liken</a><br>译文链接： <a href="http://www.importnew.com/16841.html" target="_blank" rel="external">http://www.importnew.com/16841.html</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/posts/2015/10/07/设计模式学习/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">如何读关于设计模式的那几本书</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>




<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Stackoverflow上人气最旺的十个Java问题" data-title="Stackoverflow上人气最旺的十个Java问题" data-url="http://yoursite.com/posts/2015/10/15/Stackoverflow上人气最旺的十个Java问题/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    	</div>
      <div class="footer-center" >
      &copy; 2015 Ola·火力全開
      </div>
    	<div class="footer-center">
    	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>